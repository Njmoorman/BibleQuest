# ==========================================================
# Bible Quest iOS Build — Codemagic Workflow
#
# Default mode ships to TestFlight. When you're ready for the
# App Store, flip the two flags under `publishing.app_store_connect`:
#   submit_to_testflight: false
#   submit_to_app_store: true
# ==========================================================

workflows:
  bible-quest-ios:
    name: Bible Quest for Kids – iOS Build (.NET MAUI)
    max_build_duration: 60
    environment:
      xcode: latest
      cocoapods: default
      node: 18.16.0
      groups:
        - appstore_credentials
      vars:
        DOTNET_ROOT: /Users/builder/.dotnet
        DOTNET_CLI_HOME: /Users/builder/.dotnet
        DOTNET_SKIP_FIRST_TIME_EXPERIENCE: "1"
        DOTNET_CLI_TELEMETRY_OPTOUT: "1"
        APP_IDENTIFIER: app.biblequest
        TEAM_ID: 2989BXM365
        VITE_BASE44_REQUIRE_AUTH: "false" # Keep TestFlight builds usable until login UX is ready
        AUTO_CLEAR_TESTFLIGHT_REVIEW: "true" # Cancel stuck beta-review submissions before Codemagic resubmits
    integrations:
      app_store_connect: CODE MAGIC API - Distribution (Admin)
    triggering:
      events:
        - push
        - pull_request   # Catch PR changes before merge to keep TestFlight/App Store ready
      branch_patterns:
        - pattern: main
          include: true
    scripts:
      - name: Install .NET SDK locally (no sudo required)
        script: |
          set -euo pipefail
          DOTNET_VERSION="8.0.301"
          mkdir -p "$DOTNET_ROOT"
          curl -sSL https://dot.net/v1/dotnet-install.sh -o /tmp/dotnet-install.sh
          chmod +x /tmp/dotnet-install.sh
          /tmp/dotnet-install.sh --version "$DOTNET_VERSION" --install-dir "$DOTNET_ROOT"
          export PATH="$DOTNET_ROOT:$PATH"
          dotnet --info

      - name: Install MAUI workload
        script: |
          set -euo pipefail
          export PATH="$DOTNET_ROOT:$PATH"
          mkdir -p "$HOME/.dotnet/temp"
          dotnet workload install maui-ios --skip-manifest-update --temp-dir "$HOME/.dotnet/temp"
          dotnet workload restore BibleQuestForKids/BibleQuestForKids.csproj

      - name: Build bundled web assets (npm)
        script: |
          set -euo pipefail
          cd BibleQuestForKids/wwwroot
          npm ci
          npm run build

          # Strip web build dependencies so MAUI only packages the compiled Vite output.
          rm -rf node_modules src
          rm -f package.json package-lock.json vite.config.js tailwind.config.js postcss.config.js eslint.config.js jsconfig.json components.json README.md

      - name: Restore NuGet packages
        script: |
          set -euo pipefail
          export PATH="$DOTNET_ROOT:$PATH"
          dotnet restore BibleQuestForKids/BibleQuestForKids.csproj

      - name: Configure Apple signing assets
        script: |
          set -euo pipefail
          pick_env_name() {
            for var_name in "$@"; do
              eval "value=\${$var_name-}"
              if [ -n "$value" ]; then
                printf '%s' "$var_name"
                return 0
              fi
            done
            echo "Missing required signing variable. Please define one of: $*" >&2
            exit 1
          }

          CERTIFICATE_VAR=$(pick_env_name IOS_CERTIFICATE_P12 CM_CERTIFICATE_P12 IOS_DISTRIBUTION_CERTIFICATE APPLE_CERTIFICATE_P12 APPLE_DISTRIBUTION_CERTIFICATE CERTIFICATE_PRIVATE_KEY)
          PASSWORD_VAR=$(pick_env_name IOS_CERTIFICATE_PASSWORD CM_CERTIFICATE_PASSWORD IOS_DISTRIBUTION_CERTIFICATE_PASSWORD APPLE_CERTIFICATE_PASSWORD APPLE_DISTRIBUTION_CERTIFICATE_PASSWORD CERTIFICATE_PASSWORD)
          PROFILE_VAR=$(pick_env_name IOS_PROVISIONING_PROFILE CM_PROVISIONING_PROFILE IOS_DISTRIBUTION_PROFILE APPLE_PROVISIONING_PROFILE IOS_PROVISIONING_PROFILE_BASE64 PROVISIONING_PROFILE)

          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"

          SIGNING_DIR="$HOME/codemagic-signing"
          KEYCHAIN_PATH="$HOME/Library/Keychains/codemagic-signing.keychain-db"
          CERT_PATH="$SIGNING_DIR/apple_distribution.p12"
          PROFILE_TMP="$SIGNING_DIR/profile.mobileprovision"
          PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"

          mkdir -p "$SIGNING_DIR" "$PROFILES_DIR"

          echo "Using signing certificate from \"$CERTIFICATE_VAR\""
          echo "Using provisioning profile from \"$PROFILE_VAR\""

          eval "printf '%s' \"\${$CERTIFICATE_VAR}\"" | base64 --decode > "$CERT_PATH"
          eval "printf '%s' \"\${$PROFILE_VAR}\"" | base64 --decode > "$PROFILE_TMP"
          CERTIFICATE_PASSWORD=$(eval "printf '%s' \"\${$PASSWORD_VAR}\"")

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -d user -s "$KEYCHAIN_PATH"

          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          PROFILE_PLIST=$(security cms -D -i "$PROFILE_TMP")
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print UUID' /dev/stdin <<< "$PROFILE_PLIST")
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print Name' /dev/stdin <<< "$PROFILE_PLIST")
          mv "$PROFILE_TMP" "$PROFILES_DIR/$PROFILE_UUID.mobileprovision"
          echo "Installed provisioning profile '$PROFILE_NAME' ($PROFILE_UUID)"

          IOS_IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | awk -F '"' 'NR==1 {print $2}')
          if [ -z "$IOS_IDENTITY" ]; then
            echo "No signing identity available" >&2
            exit 1
          fi
          echo "Using signing identity: $IOS_IDENTITY"

          export SIGNING_KEYCHAIN_PATH="$KEYCHAIN_PATH"
          export PROVISIONING_PROFILE_UUID="$PROFILE_UUID"
          export IOS_CODESIGN_IDENTITY="$IOS_IDENTITY"
          export KEYCHAIN_PASSWORD="$KEYCHAIN_PASSWORD"

          printf 'export SIGNING_KEYCHAIN_PATH=%q\n' "$SIGNING_KEYCHAIN_PATH" >> "$CM_ENV"
          printf 'export PROVISIONING_PROFILE_UUID=%q\n' "$PROVISIONING_PROFILE_UUID" >> "$CM_ENV"
          printf 'export IOS_CODESIGN_IDENTITY=%q\n' "$IOS_CODESIGN_IDENTITY" >> "$CM_ENV"
          printf 'export KEYCHAIN_PASSWORD=%q\n' "$KEYCHAIN_PASSWORD" >> "$CM_ENV"

      - name: Align Info.plist bundle ID with provisioning profile
        script: |
          set -euo pipefail
          : "${APP_IDENTIFIER:?Define APP_IDENTIFIER in workflow vars or Codemagic env groups}"
          INFO_PLIST="BibleQuestForKids/Platforms/iOS/Info.plist"
          CURRENT_ID=$(/usr/libexec/PlistBuddy -c 'Print CFBundleIdentifier' "$INFO_PLIST")
          if [ "$CURRENT_ID" != "$APP_IDENTIFIER" ]; then
            echo "Updating CFBundleIdentifier from '$CURRENT_ID' to '$APP_IDENTIFIER'"
            /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $APP_IDENTIFIER" "$INFO_PLIST"
          else
            echo "CFBundleIdentifier already matches $APP_IDENTIFIER"
          fi

      - name: Stamp Info.plist version numbers
        script: |
          set -euo pipefail
          INFO_PLIST="BibleQuestForKids/Platforms/iOS/Info.plist"

          pick_display_version() {
            if [ -n "${APP_VERSION-}" ]; then
              printf '%s' "$APP_VERSION"; return
            fi
            if [ -n "${APP_DISPLAY_VERSION-}" ]; then
              printf '%s' "$APP_DISPLAY_VERSION"; return
            fi
            if [ -n "${CM_TAG-}" ]; then
              printf '%s' "${CM_TAG#v}"; return
            fi
            printf '1.0.0'
          }

          pick_build_number() {
            if [ -n "${APP_BUILD_NUMBER-}" ]; then
              printf '%s' "$APP_BUILD_NUMBER"; return
            fi
            if [ -n "${BUILD_NUMBER-}" ]; then
              printf '%s' "$BUILD_NUMBER"; return
            fi
            if [ -n "${CM_BUILD_ID-}" ]; then
              printf '%s' "$CM_BUILD_ID"; return
            fi
            printf '1'
          }

          APP_DISPLAY_VERSION=$(pick_display_version)
          APP_BUILD_NUMBER=$(pick_build_number)

          echo "Stamping CFBundleShortVersionString=$APP_DISPLAY_VERSION"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $APP_DISPLAY_VERSION" "$INFO_PLIST"
          echo "Stamping CFBundleVersion=$APP_BUILD_NUMBER"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $APP_BUILD_NUMBER" "$INFO_PLIST"

          printf 'export APP_DISPLAY_VERSION=%q\n' "$APP_DISPLAY_VERSION" >> "$CM_ENV"
          printf 'export APP_BUILD_NUMBER=%q\n' "$APP_BUILD_NUMBER" >> "$CM_ENV"

      - name: Materialize iOS AppIcon PNGs
        script: |
          set -euo pipefail
          python3 BibleQuestForKids/Platforms/iOS/Assets.xcassets/AppIcon.appiconset/materialize_icons.py

      - name: Validate iOS icon catalog
        script: |
          set -euo pipefail
          ICONSET="BibleQuestForKids/Platforms/iOS/Assets.xcassets/AppIcon.appiconset"
          if [ ! -d "$ICONSET" ]; then
            echo "Missing $ICONSET" >&2
            exit 1
          fi
          # Keep validation logic in a standalone script so Base44/Codemagic runs stay readable.
          python3 "$ICONSET/validate_icons.py" "$ICONSET"
          
      - name: Publish .NET MAUI iOS app
        script: |
          set -euo pipefail
          if [ -f "${CM_ENV-}" ]; then
            . "$CM_ENV"
          fi
          : "${IOS_CODESIGN_IDENTITY:?Missing IOS_CODESIGN_IDENTITY from signing step}"
          : "${PROVISIONING_PROFILE_UUID:?Missing PROVISIONING_PROFILE_UUID from signing step}"
          : "${SIGNING_KEYCHAIN_PATH:?Missing SIGNING_KEYCHAIN_PATH from signing step}"
          : "${APP_IDENTIFIER:?Define APP_IDENTIFIER in workflow vars or Codemagic env groups}"
          : "${APP_DISPLAY_VERSION:?Stamp Info.plist version numbers before publishing}"
          : "${APP_BUILD_NUMBER:?Stamp Info.plist version numbers before publishing}"
          export PATH="$DOTNET_ROOT:$PATH"
          dotnet publish BibleQuestForKids/BibleQuestForKids.csproj \
            -c Release \
            -f net8.0-ios \
            -p:RuntimeIdentifier=ios-arm64 \
            -p:ArchiveOnBuild=true \
            -p:CreatePackage=true \
            -p:ApplicationId="$APP_IDENTIFIER" \
            -p:CFBundleIdentifier="$APP_IDENTIFIER" \
            -p:ApplicationDisplayVersion="$APP_DISPLAY_VERSION" \
            -p:ApplicationVersion="$APP_BUILD_NUMBER" \
            -p:CodesignKey="$IOS_CODESIGN_IDENTITY" \
            -p:CodesignProvision="$PROVISIONING_PROFILE_UUID" \
            -p:CodesignKeychain="$SIGNING_KEYCHAIN_PATH"

      - name: Collect IPA
        script: |
          set -euo pipefail
          mkdir -p output
          find BibleQuestForKids/bin/Release/net8.0-ios/ios-arm64/publish -maxdepth 1 -name '*.ipa' \
            -print -exec cp {} output/ \;

      - name: Clear in-flight TestFlight beta review (optional)
        script: |
          set -euo pipefail

          if [ "${AUTO_CLEAR_TESTFLIGHT_REVIEW:-true}" != "true" ]; then
            echo "AUTO_CLEAR_TESTFLIGHT_REVIEW disabled; keeping existing beta review submission in place."
            exit 0
          fi

          required_vars=(APP_STORE_CONNECT_PRIVATE_KEY APP_STORE_CONNECT_KEY_IDENTIFIER APP_STORE_CONNECT_ISSUER_ID APP_IDENTIFIER)
          for var in "${required_vars[@]}"; do
            if [ -z "${!var:-}" ]; then
              echo "Missing required App Store Connect configuration: $var" >&2
              exit 1
            fi
          done

          ruby <<'RUBY'
            require 'openssl'
            require 'base64'
            require 'json'
            require 'net/http'
            require 'uri'

            def env!(name)
              ENV.fetch(name) do
                warn "Missing required environment variable: #{name}"
                exit 1
              end
            end

            def pad_component(component)
              bytes = component.to_s(2)
              if bytes.bytesize < 32
                ("\x00" * (32 - bytes.bytesize)) + bytes
              elsif bytes.bytesize > 32
                bytes[-32, 32]
              else
                bytes
              end
            end

            def build_token(private_key_pem, key_id, issuer_id)
              key = OpenSSL::PKey::EC.new(private_key_pem)
              header = { alg: 'ES256', kid: key_id, typ: 'JWT' }
              payload = { iss: issuer_id, exp: Time.now.to_i + 20 * 60, aud: 'appstoreconnect-v1' }
              segments = [header, payload].map { |part| Base64.urlsafe_encode64(part.to_json, padding: false) }
              signing_input = segments.join('.')
              digest = OpenSSL::Digest::SHA256.digest(signing_input)
              der_signature = key.dsa_sign_asn1(digest)
              asn1 = OpenSSL::ASN1.decode(der_signature)
              r_bn, s_bn = asn1.value.map(&:value)
              signature_raw = pad_component(r_bn) + pad_component(s_bn)
              signature_b64 = Base64.urlsafe_encode64(signature_raw, padding: false)
              "#{signing_input}.#{signature_b64}"
            end

            def normalize_private_key(raw)
              expanded = raw.include?('-----BEGIN') ? raw : Base64.decode64(raw)
              expanded.gsub("\\n", "\n")
            end

            bundle_id = env!('APP_IDENTIFIER')
            private_key = normalize_private_key(env!('APP_STORE_CONNECT_PRIVATE_KEY'))
            key_id = env!('APP_STORE_CONNECT_KEY_IDENTIFIER')
            issuer_id = env!('APP_STORE_CONNECT_ISSUER_ID')

            token = build_token(private_key, key_id, issuer_id)

            api_host = 'https://api.appstoreconnect.apple.com'
            apps_uri = URI("#{api_host}/v1/apps")
            apps_uri.query = URI.encode_www_form('filter[bundleId]' => bundle_id, 'include' => 'betaAppReviewSubmissions')
            apps_req = Net::HTTP::Get.new(apps_uri)
            apps_req['Authorization'] = "Bearer #{token}"

            apps_res = Net::HTTP.start(apps_uri.host, apps_uri.port, use_ssl: true) { |http| http.request(apps_req) }
            unless apps_res.is_a?(Net::HTTPSuccess)
              warn "Failed to query App Store Connect apps: #{apps_res.code} #{apps_res.body}"
              exit 1
            end

            payload = JSON.parse(apps_res.body)
            data = payload.fetch('data', [])
            if data.empty?
              warn "No App Store Connect app found for bundle id #{bundle_id}"
              exit 1
            end

            review_resources = (payload['included'] || []).select { |resource| resource['type'] == 'betaAppReviewSubmissions' }
            actionable = review_resources.select do |resource|
              %w[WAITING_FOR_REVIEW IN_REVIEW].include?(resource.dig('attributes', 'betaReviewState'))
            end

            if actionable.empty?
              puts 'No in-flight Beta App Review submissions to cancel.'
              exit 0
            end

            actionable.each do |submission|
              submission_id = submission.fetch('id')
              state = submission.dig('attributes', 'betaReviewState')
              puts "Cancelling Beta App Review submission #{submission_id} (state: #{state})"
              delete_uri = URI("#{api_host}/v1/betaAppReviewSubmissions/#{submission_id}")
              delete_req = Net::HTTP::Delete.new(delete_uri)
              delete_req['Authorization'] = "Bearer #{token}"
              delete_res = Net::HTTP.start(delete_uri.host, delete_uri.port, use_ssl: true) { |http| http.request(delete_req) }
              unless delete_res.is_a?(Net::HTTPNoContent)
                warn "Unable to cancel submission #{submission_id}: #{delete_res.code} #{delete_res.body}"
                exit 1
              end
            end
            puts "Cleared #{actionable.length} TestFlight beta review submission(s)."
          RUBY

    artifacts:
      - output/*.ipa

    publishing:
      app_store_connect:
        auth: integration
        submit_to_testflight: true
        submit_to_app_store: false
